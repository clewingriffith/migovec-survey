#!/usr/bin/env python

"""
Searches through the tiles generated by createTiles.py and builds a map
of duplicate tile -> original tile pointers. This allows us to delete all the 
duplicates and reference only the original set, cutting down on the
number of tiles.

eg. in the 1976 survey, we have tiles covering the Galactica chamber.
No further exploration has taken place, so these tiles will be exactly 
the same in all years after 1976. We keep the 1976 tiles and map
later years tiles to the 1976 ones.
"""

import os
import fnmatch
import re
import subprocess
import multiprocessing

"""
Returns the tile path to use for the comparison tile. If it's the same as the base tile
we will map the comparison tile to the base tile and use that. Otherwise it maps
to itself.
"""
def isDuplicate((baseTile, comparisonTile)):
	output = subprocess.check_output("compare -metric RMSE " + baseTile + " " +comparisonTile + " NULL: 2>&1", shell=True)
	#print "==>",output
	if "0 (0)" == output.strip():
		return True
	else:
		return False

def isBlankTile(tile):
	output = subprocess.check_output("identify -format '%k' " +tile, shell=True)
	if "1" == output.strip():
		return True
	else:
		return False


#def getResolvedTilePath(previous_year_similarity, tilepath):
#	pass

tilePathRegex = re.compile(r"build/survey/year/(\d+)/survey/SysMig/(\w+)/(t_\w+.png)")

def unpath(tilepath):
	result = tilePathRegex.search(tilepath)
	year,orientation,tile = result.group(1),result.group(2),result.group(3)
	return (year,orientation,tile)

def getPath(year,orientation,tile):
	return "build/survey/year/%s/survey/SysMig/%s/%s" % (year,orientation,tile)

def redundantTile((tile1,tile2)):
	if tile1 != tile2:
		return tile1
	else:
		return None

if __name__ == '__main__':

	print "Finding Duplicate map tiles"
	print "==========================="
	
	all_years = os.listdir('build/survey/year/')
	all_years.sort()
	print "Analysing years: ",all_years
	
	earliest_year = all_years[0]

	other_years = all_years[1:]
	
	earliest_year_tiles = []
	other_year_tiles = []
	
	for root, dirnames, filenames in os.walk('build/survey/year/'+earliest_year):
	  for filename in fnmatch.filter(filenames, 't_*.png'):
	      earliest_year_tiles.append(os.path.join(root, filename))
	#print earliest_year_tiles
	
	#~ for root,filename in earliest_year_tiles:
		#~ print root,filename
		#~ #base_tile = 'src/static/blank_tile.png'
		#~ tile_path = os.path.join(root,filename)
		#~ comparison_pairs.append((base_tile, comparison_tile))
		
	orientations = ('plan','extendedElevation')
	
	previous_year_similarity = {}
	
	for orientation in orientations:
		previous_year_similarity[orientation] = { '0':{} }
		
	is_blank_result = map(isBlankTile, earliest_year_tiles)
	for tile,isBlank in zip(earliest_year_tiles, is_blank_result):
		year,orientation,tile = unpath(tile)
		o = previous_year_similarity[orientation]
		if not o.has_key(year):
			o[year] = {}
		if isBlank:
			o[year][tile]='0'
	
	
		#print tile, isBlank
	
	#Find duplicates between years
	
	year_pairings = zip(all_years,other_years)
	print "year pairings",year_pairings
	comparison_pairs = []
	for early_year_tilepath in earliest_year_tiles:
		#print root,filename
		early_year,orientation,tile = unpath(early_year_tilepath)
		
		for y1,y2 in year_pairings:
			base_tile = getPath(y1,orientation,tile)
			comparison_tile = getPath(y2,orientation,tile)
			comparison_pairs.append((base_tile, comparison_tile))
	
	#print "ComparisonPairs",comparison_pairs
	
	comparison_tile_mapping = map(isDuplicate, comparison_pairs)
	for duplicate_flag, (baseTile,comparisonTile) in zip(comparison_tile_mapping, comparison_pairs):
		y1,orientation,tile = unpath(baseTile)
		y2,orientation,tile = unpath(comparisonTile)
		#print comparisonTile + "@" + y2 + "->" y1
		sim=previous_year_similarity[orientation]
		if not sim.has_key(y2):
			sim[y2]={}
		if duplicate_flag == True:
			sim[y2][tile] = y1
	

	
	#Flatten previous year similarity structure into mapping of tile paths to filenames to use
	
	
	def getTilePath(tile,year,orientation):
		if year == '0':
			return 'survey/blank_tile.png'
		else:
			return 'survey/year/%s/survey/SysMig/%s/%s' % (year, orientation, tile) 

	def resolveTile(tile, year, orientation):
		duplicates_for_year = previous_year_similarity[orientation][year]
		if duplicates_for_year.has_key(tile):
			#The tile was defined in a previous year
			#print 'rec'
			return resolveTile(tile, duplicates_for_year[tile], orientation)
		else:
			return tile,year,orientation
			#The tile is new this year
			return getTilePath(tile,year,orientation)
	
	def resolveTilePath(unresolvedTilePath):
		year,orientation,tile = unpath(unresolvedTilePath)
		t1,y1,o1 = resolveTile(tile, year, orientation)
		return getTilePath(t1,y1,o1)
		
	
	all_tilepaths = []
	for root, dirnames, filenames in os.walk('build/survey/year/'):
	  for filename in fnmatch.filter(filenames, 't_*.png'):
	      all_tilepaths.append(os.path.join(root, filename))
	
	print "Resolved tiles:"
	tile_mapping = zip(all_tilepaths, map(resolveTilePath, all_tilepaths))
	
	redundant_tiles = [t1 for t1,t2 in tile_mapping if t1!=t2]
	print "Found",len(redundant_tiles),"redundant tiles"
	#print "Redundant tiles:"
	
	#create the final map of tile request to actual tile to serve. We transform the 
	#paths to relative so that the google app engine server can pick them up.
	final_tile_mapping = {}
	for t1,t2 in tile_mapping:
		final_tile_mapping[t1.replace("build/","")]=t2
	
	import pprint

	
	mapping_output = open('build/duplicate_tile_mapping.py','w')
	print >>mapping_output, "tile_mapping=",
	pprint.pprint(final_tile_mapping, stream=mapping_output )
	#print >>mapping_output, "tile_mapping =",final_tile_mapping
	mapping_output.close()
	print "Generated tile mapping ","build/duplicate_tile_mapping.py"
	print "Done."
	
	#
	#print resolveTilePath("build/survey/year/1994/survey/SysMig/extendedElevation/t_16_35273_23250.png")
	
	
	
	
	
	
	
	#print "Found ",len(filter(None,comparison_tile_mapping))," duplicate tiles"
	
	
	#build a map of tiles to year in which a duplicate is found, eg.
	"""
	{
		1976: { tile1: 0, tile3:0, tile4:0}
		1994: { tile1: 1976, tile2:tile2, tile3:1976, tile4:1976}
		1995: { tile1: 1994, tile2:tile2, tile3:tile3, tile4:1994}
	}
	"""
	
	"""
	orientations = ('plan','extendedElevation')
	
	previous_year_similarity = {}
	
	for orientation in orientations:
		previous_year_similarity[orientation] = { 0:{} }
	#An entry of 0 means the tile is blank
	
	
	

	
	
	#generate a blank tile mapping on the earliest year
	comparison_pairs = []
	for root,filename in earliest_year_tiles:
		#print root,filename
		base_tile = 'src/static/blank_tile.png'
		comparison_tile = os.path.join(root,filename)
		comparison_pairs.append((base_tile, comparison_tile))
		
	comparison_tile_mapping = map(getBlankTileMapping, comparison_pairs)
	blank_tile_mapping = {}
	
	for mapped_tile, (baseTile,comparisonTile) in zip(comparison_tile_mapping, comparison_pairs):
		blank_tile_mapping[comparisonTile] = mapped_tile
	
	import pprint
	pprint.pprint(blank_tile_mapping)
	#Look through the later years and map to  the earliest year tile
	"""
	"""
	comparison_pairs = []
	for root,filename in earliest_year_tiles:
		#print root,filename
		base_tile = os.path.join(root,filename)
		for year in other_years:
			comparison_tile = os.path.join(root.replace(earliest_year, year), filename)
			comparison_pairs.append((base_tile, comparison_tile))
	
	#for base_tile, comparison_tile in comparison_pairs:
	#	isDuplicateTileContent(base_tile, comparison_tile)
	
	#pool = multiprocessing.Pool(processes=multiprocessing.cpu_count())
	#comparison_results = pool.map(isDuplicateTileContent,  comparison_pairs)
	
	comparison_tile_mapping = map(getDuplicateTileMapping, comparison_pairs)
	print "Found ",len(filter(None,comparison_tile_mapping))," duplicate tiles"
	
	final_tile_mapping = {}
	
	for mapped_tile, (baseTile,comparisonTile) in zip(comparison_tile_mapping, comparison_pairs):
		final_tile_mapping[comparisonTile] = mapped_tile
		
	mapping_output = open('build/duplicate_tile_mapping.py','w')
	
	print >>mapping_output, "tile_mapping =",final_tile_mapping
	mapping_output.close()
	print "Generated tile mapping ","build/duplicate_tile_mapping.py"
	print "Done."
	"""